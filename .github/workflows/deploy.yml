name: Deploy Total Life AI

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write   # for AWS OIDC
  contents: read

env:
  AWS_REGION: us-east-1
  STACK_NAME: TotalLifeAI-Prod-Clean
  ECR_REPOSITORY: totallifeai-backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Retrieve CloudFormation stack outputs
        id: cfn
        run: |
          set -e
          CF_JSON=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")
          echo "ALB_DNS=$(echo "$CF_JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="LoadBalancerDNS").OutputValue')" >> $GITHUB_ENV
          echo "CLOUDFRONT_DOMAIN=$(echo "$CF_JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="CloudFrontDomainName").OutputValue')" >> $GITHUB_ENV
          echo "FRONTEND_BUCKET=$(echo "$CF_JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="FrontendBucketName").OutputValue')" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$(echo "$CF_JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="ClusterName").OutputValue')" >> $GITHUB_ENV
          echo "SERVICE_NAME=$(echo "$CF_JSON" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey=="ServiceName").OutputValue')" >> $GITHUB_ENV

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com

      - name: Build and push backend image
        run: |
          IMAGE_URI=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          docker build -t $IMAGE_URI:latest .
          docker push $IMAGE_URI:latest

      - name: Register new task definition (with new image)
        run: |
          TD_ARN=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" --query 'services[0].taskDefinition' --output text)
          TD_JSON=$(aws ecs describe-task-definition --task-definition "$TD_ARN" --query 'taskDefinition')
          IMAGE_URI=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:latest
          echo "$TD_JSON" | jq --arg img "$IMAGE_URI" 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy) | .containerDefinitions[0].image=$img' > td.json
          NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://td.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_ENV

      - name: Run Alembic migrations (one-off task)
        run: |
          NET_JSON=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" --query 'services[0].networkConfiguration.awsvpcConfiguration')
          SUBNETS=$(echo "$NET_JSON" | jq -r '.subnets | join(",")')
          SGS=$(echo "$NET_JSON" | jq -r '.securityGroups | join(",")')
          ASSIGN=$(echo "$NET_JSON" | jq -r '.assignPublicIp')
          CONTAINER=$(cat td.json | jq -r '.containerDefinitions[0].name')
          aws ecs run-task --cluster "$CLUSTER_NAME" --launch-type FARGATE --task-definition "$NEW_TD_ARN" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SGS],assignPublicIp=$ASSIGN}" \
            --overrides "{\"containerOverrides\":[{\"name\":\"$CONTAINER\",\"command\":[\"alembic\",\"-c\",\"/app/alembic.ini\",\"upgrade\",\"head\"]}]}" \
            --query 'tasks[0].taskArn' --output text > task_arn.txt
          TASK_ARN=$(cat task_arn.txt)
          aws ecs wait tasks-stopped --cluster "$CLUSTER_NAME" --tasks "$TASK_ARN" || true
          CODE=$(aws ecs describe-tasks --cluster "$CLUSTER_NAME" --tasks "$TASK_ARN" --query 'tasks[0].containers[0].exitCode' --output text)
          if [ "$CODE" != "0" ]; then
            echo "Migration failed with code $CODE" >&2
            exit 1
          fi

      - name: Update ECS service
        run: |
          aws ecs update-service --cluster "$CLUSTER_NAME" --service "$SERVICE_NAME" --task-definition "$NEW_TD_ARN" --force-new-deployment > /dev/null
          aws ecs wait services-stable --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME"

      - name: Build frontend
        working-directory: frontend
        run: |
          npm ci
          echo "REACT_APP_API_URL=/api/v1" > .env.production
          echo "REACT_APP_ENVIRONMENT=production" >> .env.production
          npm run build

      - name: Deploy frontend to S3
        run: |
          aws s3 sync frontend/build/ s3://$FRONTEND_BUCKET/ --delete --cache-control "public, max-age=300, must-revalidate" --exclude "static/*"
          aws s3 sync frontend/build/static/ s3://$FRONTEND_BUCKET/static/ --delete --cache-control "public, max-age=31536000, immutable"

      - name: Invalidate CloudFront
        run: |
          DIST_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?DomainName=='$CLOUDFRONT_DOMAIN'].Id" --output text)
          if [ -n "$DIST_ID" ] && [ "$DIST_ID" != "None" ]; then
            aws cloudfront create-invalidation --distribution-id "$DIST_ID" --paths "/*"
          fi

